<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2020/07/22/SwiftUI-explore/"/>
      <url>/2020/07/22/SwiftUI-explore/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>前言: <code>iOS</code>开发者的<code>UI</code>开发体验一直在大前端中体验是比较差的, 原始的<code>Frame</code>布局系统,  API比较难用的<code>Autolayout</code>, 性能相对较差的<code>Xib</code>, <code>SB</code>, 而对于基础的业务开发, UI的开发又占用了大量的时间, 但是在2019 WWDC上Apple给我们带来了新的布局方式 “SwiftUI”;  SwiftUI对大量的UI控件进行了重新”定义” Text, Button, List等等</p><h3 id="1-SwiftUI的优缺点"><a href="#1-SwiftUI的优缺点" class="headerlink" title="1. SwiftUI的优缺点"></a>1. SwiftUI的优缺点</h3><p>1.1 SwiftUI的优势</p><ul><li>声明式UI语法</li><li>亚秒级别的实时刷新</li><li>官方原生的大力支持</li><li>实时预览功能, 可视化修改增删代码</li></ul><p>1.2 SwiftUI的劣势</p><ul><li>iOS13以后支持</li><li>API的不稳定性</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggx9mt2ojqj30l00l813c.jpg" alt="截屏2020-07-20 上午10.46.47" style="zoom:50%;"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggx9n2kt9ij30h20r2tlr.jpg" alt="截屏2020-07-20 上午10.50.54" style="zoom:50%;"></p><h3 id="2-语法细节-声明式语法"><a href="#2-语法细节-声明式语法" class="headerlink" title="2. 语法细节-声明式语法"></a>2. 语法细节-声明式语法</h3><pre class=" language-Swift"><code class="language-Swift">struct TextTest: View &#123;    var body: some View &#123;        VStack(spacing: 15) &#123;            Text("SwiftUI")            Text("SwiftUI")                .foregroundColor(.orange)                .bold()                .font(.system(.largeTitle))                .fontWeight(.medium)                .italic()                .shadow(color: .black, radius: 1, x: 0, y: 2)            Text(summerxx)                .underline(true, color: Color.gray)                .font(.system(size: 16, design: .serif)).onTapGesture &#123;                    print(summerxx)            &#125;            HStack &#123;                Text("Text")                Text("Text.bold").bold()                Text("SecureField").foregroundColor(.orange)            &#125;            Text("Views and controls are the visual building blocks of your app’s user interface." +                " Use them to present your app’s content onscreen.")                .lineLimit(nil)        &#125;    &#125;&#125;</code></pre><ul><li>同是声明式布局, Flutter给人眼花缭乱的感觉, 而Swift 的 View 组合并不是由<code>,</code> 分割，而是由换行分割，在 Swift 中 函数调用是可以换行分割的。这样的方式对开发者的体验更为友好</li></ul><h3 id="3-实时预览"><a href="#3-实时预览" class="headerlink" title="3. 实时预览"></a>3. 实时预览</h3><p>曾经我是很羡慕前端的同学实时预览的, 有时候一个项目编译链接要几分钟, 我写一个UI效果想看看很令人头大, 但是现在Apple平台上也拥有了同样的方式, 这次 苹果官方 给开发者带来了此项功能。</p><ul><li><p>Macos catalina Xcode11以上, SwiftUI就可以尝鲜此项功能不仅可以实时预览</p></li><li><p>还可以自动填充代码, 大大的方便了广大开发者. 泪目.GIF</p></li><li><p>可以通过 Group 功能同时预览多个设备，多个不同的环境</p></li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyzc49erqj311a0kcnk5.jpg" alt="截屏2020-07-21 22.49.25" style="zoom:50%;"><p>备注: SwiftUI 可以在 Xcode 里面直接切换 LiveMode 可以不运行设备直接进入交互模式，再具有多个预览设备时可以很方便的动态调试 UI 布局。如何进入多设备预览模式? 代码如下:</p><pre class=" language-Swift"><code class="language-Swift">struct TextTest_Previews: PreviewProvider &#123;    static var previews: some View &#123;        Group &#123;            TextTest()                .previewDevice("iPhone 8")            TextTest()                .previewDevice("iPhone 11 Pro Max")        &#125;    &#125;&#125;</code></pre><h3 id="4-Xcode-Library"><a href="#4-Xcode-Library" class="headerlink" title="4.  Xcode Library"></a>4.  Xcode Library</h3><p>在编写真实项目中，一个公司的 APP UI 包含成百上千种风格的 View 组件，对于 UI 组件丰富的产品，如果一个新需求可以由现有的组件组合，那么需求交付的时间也会大大缩短。<br>但是对于一个大型的开发团队而言，一个开发同学是很难知道公司内到底有多少种组件库，而且即便知道有某种组件库，开发同学初期看到的也是代码，一般需要书写一定的 Demo 才可以用眼睛感知到这个组件到底是否是我想要的。</p><p>在 Xcode 12 中提供了更强大的工具，一个自定义组件，只需要遵守一个 LiberyContentProvider 协议就可被Xcode识别，可以像系统控件一样直接从 Xcode 里面识别并预览。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggzsgxjonyj30zo0r8gom.jpg" alt="截屏2020-07-22 下午3.37.20" style="zoom: 50%;"><h3 id="5-Switch-Case-Support"><a href="#5-Switch-Case-Support" class="headerlink" title="5. Switch Case Support"></a>5. Switch Case Support</h3><p>在 SwiftUI 的 ViewBuilder DSL体系中也支持了 Switch case 语法</p><pre class=" language-Swift"><code class="language-Swift"> var body: some View &#123;            switch c &#123;            case .a:                return Text("A")            case .b:                return Text("B")            case .c:                return Text("C")            &#125;        &#125;</code></pre><h3 id="6-Data-Flow-数据流"><a href="#6-Data-Flow-数据流" class="headerlink" title="6. Data Flow 数据流"></a>6. Data Flow 数据流</h3><p>在使用传统命令式编程编写 UI 代码时，开发者需要手动处理 UIView 和 数据之间的依赖关系, 那么 SwiftUI 是如何解决这个问题的？</p><ol><li>统一的 body 属性，SwiftUI 自动从当前 App 状态集自动生成基于当前状态的快照 View。</li><li>统一的数据流动原语</li><li>今年 SwiftUI 2.0 新增的 StateObject 数据流原语让 SwiftUI 在重复创建 View 时避免重复创建 ObservedObject 从而提高 View 重建的性能。</li><li>SceneStorage 和 APPStorgae 让一些可持久化的数据变得更加简单且具有语义化。</li></ol><h3 id="7-New-Controls"><a href="#7-New-Controls" class="headerlink" title="7. New Controls"></a>7. New Controls</h3><p>2020年真正重要的是今年新增的各类新控件，其中通过导出来自 Xcode11.5 和 Xcode12.0 beta 版本的 Swift 声明文件，可以观察到整个声明文件从原来的 <code>10769</code> 行增加到<code> 20564</code>行。</p><p>新增了约<code> 87 个 struct</code> <code>16 个 protocol</code>。有了这些丰富的组件才可以更好的构建我们的 APP 。</p><h3 id="8-复杂列表组件"><a href="#8-复杂列表组件" class="headerlink" title="8. 复杂列表组件"></a>8. 复杂列表组件</h3><p>SwiftUI 2.0 推出了 LazyHStack 和 lazyVStack 加上 List 渲染模式默认就是 Lazy 的直接解决了最大的性能问题。</p><h3 id="9-混合UIKit"><a href="#9-混合UIKit" class="headerlink" title="9. 混合UIKit"></a>9. 混合UIKit</h3><p>对于旧的技术 虽然经过了很多年的历史沉淀，有很多的积累，但是这些积累同时变成了包袱，如何背着包袱负重前行，是任何一门新技术都要考虑的问题， 显然 Swift UI 也考虑到了，目前官方给出的文档中， SwiftUI 是可以和 UIKit 原有的体系很轻松的混合在一起。让开发者可以渐进式的接入 SwiftUI。</p><h3 id="10-版本支持"><a href="#10-版本支持" class="headerlink" title="10. 版本支持"></a>10. 版本支持</h3><p>官方声称 SwiftUI 目前仅支持 iOS 13.x 以上，很多 APP 目前还在兼容 iOS 10以下 ，看起来用上 Swift UI 还需要 3年左右，但是观察今年 苹果的重大改变，包括， iOS 12 以下 蜂窝网络下载可以大于 200M , 苹果官方包优化大小 减少 50%  ，iOS 13 以上甚至完全不限制在蜂窝网络下下载的大小等, 所以我在想是否为了推行新的SwiftUI, Apple做一下向下兼容, 也未可知吧~</p><h3 id="11-全平台支持-SwiftUI-Apps"><a href="#11-全平台支持-SwiftUI-Apps" class="headerlink" title="11. 全平台支持 - SwiftUI Apps"></a>11. 全平台支持 - SwiftUI Apps</h3><p>苹果在最近几年的动作中一直在搞 Apple Platform 统一的事情，从最近几年的 iPad 多任务 多窗口，到 Mac Catalyst 再到今年更进一步直接推出了 Apple silicon 芯片更是从硬件上做到了真正统一.</p><ul><li>写法基本无差异(SwiftUI 的理念是 Learn once, Apply anywhere)</li><li>AppKit, UIKit, WatchKit 都有对应的视图实现</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggz0pr1tdsj30vy0gqwle.jpg" alt="截屏2020-07-21 23.36.46" style="zoom:50%;"><p>相较于硬件的变化, 作为软件工程师我还是要更关注软件生态的变化, 首先了解下创建 APP 时的变化, 可以看到创建新工程时有了一套全新的模板基于 SwiftUI App Lifecycle 的跨平台项目。以下是对比</p><p><strong>Before</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">SceneDelegate</span><span class="token punctuation">:</span> <span class="token builtin">UIResponder</span><span class="token punctuation">,</span> <span class="token builtin">UIWindowSceneDelegate</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> window<span class="token punctuation">:</span> <span class="token builtin">UIWindow</span><span class="token operator">?</span>    <span class="token keyword">func</span> <span class="token function">scene</span><span class="token punctuation">(</span><span class="token number">_</span> scene<span class="token punctuation">:</span> <span class="token builtin">UIScene</span><span class="token punctuation">,</span> willConnectTo session<span class="token punctuation">:</span> <span class="token builtin">UISceneSession</span><span class="token punctuation">,</span> options connectionOptions<span class="token punctuation">:</span> <span class="token builtin">UIScene</span><span class="token punctuation">.</span><span class="token builtin">ConnectionOptions</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> contentView <span class="token operator">=</span> <span class="token function">ContentView</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> windowScene <span class="token operator">=</span> scene <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">UIWindowScene</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">let</span> window <span class="token operator">=</span> <span class="token function">UIWindow</span><span class="token punctuation">(</span>windowScene<span class="token punctuation">:</span> windowScene<span class="token punctuation">)</span>            window<span class="token punctuation">.</span>rootViewController <span class="token operator">=</span> <span class="token function">UIHostingController</span><span class="token punctuation">(</span>rootView<span class="token punctuation">:</span> contentView<span class="token punctuation">)</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>window <span class="token operator">=</span> window            window<span class="token punctuation">.</span><span class="token function">makeKeyAndVisible</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>After</strong></p><pre class=" language-Swift"><code class="language-Swift">@mainstruct MyApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()        &#125;    &#125;&#125;</code></pre><p> 这次重要的变化是, 这是第一次跨平台代码，完全无需引入任何 UIKit, APPKit, WatckKit 等相关Framewok, 即可直接运行在不同平台上。这意味着我们后续在UI布局系统上可以逐渐摆脱对传统命令式 UI 编程的依赖。达到真正的平台无关。</p><h3 id="12-SwiftUI-的机会在哪里？"><a href="#12-SwiftUI-的机会在哪里？" class="headerlink" title="12. SwiftUI 的机会在哪里？"></a>12. SwiftUI 的机会在哪里？</h3><ol><li>效率</li></ol><p>从研发效率上来说， Swift 对比 Objective-C 的精简程度不言而喻，我尝试写了一些页面代码量都有一定程度的下降, 如果编写 UI 界面从 UIKit 转向了 SwiftUI 代码量更加的精简</p><ol start="2"><li>体验</li></ol><p>更少的代码意味者更小的包大小，目前国内巨头 APP iOS 端 APP 包大小都朝着 200 MB 奔去，如果能减少更多的代码对包大小也可以在 200MB 的限制下承载更多而业务。对用户的体验也有较大的提升。</p><p>更进一步由于 Swift 选择使用值类型构建整个APP，值类型的有点在于更扁平化的内联数据结构去分配内存，而不是使用更多间接指针引用，减少了大量不必要的堆内存消耗，意味着整体内存使用量的降低。对整个 APP 的稳定性也有较大的提高</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
